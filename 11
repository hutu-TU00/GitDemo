{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 9,
   "id": "4fadaa12-6187-4150-b816-c7c8b3dfd066",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'torch._C'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[9], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mos\u001b[39;00m\n\u001b[1;32m----> 2\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[0;32m      3\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mnn\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mas\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mnn\u001b[39;00m\n\u001b[0;32m      4\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01moptim\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mas\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01moptim\u001b[39;00m\n",
      "File \u001b[1;32mD:\\anaconda\\envs\\nlp_homework_zjx\\lib\\site-packages\\torch\\__init__.py:405\u001b[0m\n\u001b[0;32m    403\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m USE_GLOBAL_DEPS:\n\u001b[0;32m    404\u001b[0m         _load_global_deps()\n\u001b[1;32m--> 405\u001b[0m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_C\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m  \u001b[38;5;66;03m# noqa: F403\u001b[39;00m\n\u001b[0;32m    408\u001b[0m \u001b[38;5;28;01mclass\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mSymInt\u001b[39;00m:\n\u001b[0;32m    409\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    410\u001b[0m \u001b[38;5;124;03m    Like an int (including magic methods), but redirects all operations on the\u001b[39;00m\n\u001b[0;32m    411\u001b[0m \u001b[38;5;124;03m    wrapped node. This is used in particular to symbolically record operations\u001b[39;00m\n\u001b[0;32m    412\u001b[0m \u001b[38;5;124;03m    in the symbolic shape workflow.\u001b[39;00m\n\u001b[0;32m    413\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n",
      "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'torch._C'"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import torch\n",
    "import torch.nn as nn\n",
    "import torch.optim as optim\n",
    "import random\n",
    "import numpy as np\n",
    "import spacy\n",
    "import datasets\n",
    "import tqdm\n",
    "import evaluate"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "a81e01a6-45af-4d6d-a878-a73acfa611b0",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'torch._C'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[5], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorchtext\u001b[39;00m\n",
      "File \u001b[1;32mD:\\anaconda\\envs\\nlp_homework_zjx\\lib\\site-packages\\torchtext\\__init__.py:1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m data\n\u001b[0;32m      2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m datasets\n\u001b[0;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m utils\n",
      "File \u001b[1;32mD:\\anaconda\\envs\\nlp_homework_zjx\\lib\\site-packages\\torchtext\\data\\__init__.py:1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mbatch\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m Batch\n\u001b[0;32m      2\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mdataset\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m Dataset, TabularDataset\n\u001b[0;32m      3\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01mexample\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m Example\n",
      "File \u001b[1;32mD:\\anaconda\\envs\\nlp_homework_zjx\\lib\\site-packages\\torchtext\\data\\batch.py:1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[38;5;28;01mimport\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\n\u001b[0;32m      4\u001b[0m \u001b[38;5;28;01mclass\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mBatch\u001b[39;00m(\u001b[38;5;28mobject\u001b[39m):\n\u001b[0;32m      5\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"Defines a batch of examples along with its Fields.\u001b[39;00m\n\u001b[0;32m      6\u001b[0m \n\u001b[0;32m      7\u001b[0m \u001b[38;5;124;03m    Attributes:\u001b[39;00m\n\u001b[1;32m   (...)\u001b[0m\n\u001b[0;32m     17\u001b[0m \u001b[38;5;124;03m    Also stores the Variable for each column in the batch as an attribute.\u001b[39;00m\n\u001b[0;32m     18\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n",
      "File \u001b[1;32mD:\\anaconda\\envs\\nlp_homework_zjx\\lib\\site-packages\\torch\\__init__.py:405\u001b[0m\n\u001b[0;32m    403\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m USE_GLOBAL_DEPS:\n\u001b[0;32m    404\u001b[0m         _load_global_deps()\n\u001b[1;32m--> 405\u001b[0m     \u001b[38;5;28;01mfrom\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mtorch\u001b[39;00m\u001b[38;5;21;01m.\u001b[39;00m\u001b[38;5;21;01m_C\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;28;01mimport\u001b[39;00m \u001b[38;5;241m*\u001b[39m  \u001b[38;5;66;03m# noqa: F403\u001b[39;00m\n\u001b[0;32m    408\u001b[0m \u001b[38;5;28;01mclass\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21;01mSymInt\u001b[39;00m:\n\u001b[0;32m    409\u001b[0m \u001b[38;5;250m    \u001b[39m\u001b[38;5;124;03m\"\"\"\u001b[39;00m\n\u001b[0;32m    410\u001b[0m \u001b[38;5;124;03m    Like an int (including magic methods), but redirects all operations on the\u001b[39;00m\n\u001b[0;32m    411\u001b[0m \u001b[38;5;124;03m    wrapped node. This is used in particular to symbolically record operations\u001b[39;00m\n\u001b[0;32m    412\u001b[0m \u001b[38;5;124;03m    in the symbolic shape workflow.\u001b[39;00m\n\u001b[0;32m    413\u001b[0m \u001b[38;5;124;03m    \"\"\"\u001b[39;00m\n",
      "\u001b[1;31mModuleNotFoundError\u001b[0m: No module named 'torch._C'"
     ]
    }
   ],
   "source": [
    "import torchtext"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "6a62f1d4-5ff5-4793-85df-ce2e6fccaabf",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'random' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[6], line 3\u001b[0m\n\u001b[0;32m      1\u001b[0m seed \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m1234\u001b[39m\n\u001b[1;32m----> 3\u001b[0m \u001b[43mrandom\u001b[49m\u001b[38;5;241m.\u001b[39mseed(seed)\n\u001b[0;32m      4\u001b[0m np\u001b[38;5;241m.\u001b[39mrandom\u001b[38;5;241m.\u001b[39mseed(seed)\n\u001b[0;32m      5\u001b[0m torch\u001b[38;5;241m.\u001b[39mmanual_seed(seed)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'random' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "seed = 1234\n",
    "\n",
    "random.seed(seed)\n",
    "np.random.seed(seed)\n",
    "torch.manual_seed(seed)\n",
    "torch.cuda.manual_seed(seed)\n",
    "torch.backends.cudnn.deterministic = True"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1100308d-5c34-44e5-aa26-f25100eed4dc",
   "metadata": {},
   "source": [
    "# 数据集 Dataset"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b7d75042-feb4-410a-852b-36b8b58acd50",
   "metadata": {},
   "source": [
    "### 设置 os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com' ，这样做具体改变了什么？ "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a6150c9-7dc1-464e-b126-3230bc6d9ec7",
   "metadata": {
    "jp-MarkdownHeadingCollapsed": true
   },
   "source": [
    " os.environ  是Python中用于访问和操作环境变量的对象。 HF_ENDPOINT  是Hugging Face相关库（如  datasets 、 transformers  等）用来确定从哪里获取模型、数据集等资源的环境变量。当设置  os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'  后，Hugging Face的相关库在请求资源时，会从指定的镜像站点  https://hf-mirror.com  而不是官方默认的源去获取数据。这可以在一些情况下提高访问速度、绕过网络限制等。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bf6fb42d-18fb-4968-8d0b-779f3d7c69dd",
   "metadata": {},
   "source": [
    "### 为什么要设置HF_ENDPOINT='https://hf-mirror.com'而非直接使用官方源？ "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "afa3db96-d6f6-4c87-968e-30884d621ca5",
   "metadata": {},
   "source": [
    " 网络限制和访问问题：在某些网络环境中，官方源可能被限制访问，通过设置镜像站点可以绕过这些限制，正常获取资源。\n",
    " \n",
    " 提高下载速度：镜像站点可能在地理位置上更接近用户，或者有更好的网络带宽，从而提高下载模型和数据集的速度。\n",
    " \n",
    " 减轻官方源压力：使用镜像站点可以分散流量，减轻Hugging Face官方源的负载，有助于整个生态系统的稳定运行。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "4d6e4077-272e-4739-a0f2-960fcf3a4f59",
   "metadata": {},
   "source": [
    "## dataset = datasets.load_dataset(\"bentrevett/multi30k\") 这行代码具体完成了什么操作？"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "709e6d30-7808-4623-8b55-91a8e15a0c1e",
   "metadata": {},
   "source": [
    " 这行代码使用了Hugging Face的  datasets  库来加载名为  \"bentrevett/multi30k\"  的数据集。具体来说，它会： \n",
    " 检查本地是否已经缓存了该数据集。如果已经缓存，则直接从本地加载。\n",
    " 如果本地没有缓存，它会根据  HF_ENDPOINT  环境变量（如果已设置）指定的地址，从远程获取该数据集，并下载到本地缓存目录。\n",
    " 最后，将加载好的数据集对象赋值给变量  dataset ，后续可以对该数据集进行各种操作，如查看数据样本、进行数据预处理等。 multi30k  数据集是一个用于机器翻译和多模态研究的数据集，包含图像描述对（源语言和目标语言）。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "b5a94583-6f56-4676-99a4-735bb038f30e",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'os' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[7], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mos\u001b[49m\u001b[38;5;241m.\u001b[39menviron[\u001b[38;5;124m'\u001b[39m\u001b[38;5;124mHF_ENDPOINT\u001b[39m\u001b[38;5;124m'\u001b[39m] \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m'\u001b[39m\u001b[38;5;124mhttps://hf-mirror.com\u001b[39m\u001b[38;5;124m'\u001b[39m\n\u001b[0;32m      2\u001b[0m dataset \u001b[38;5;241m=\u001b[39m datasets\u001b[38;5;241m.\u001b[39mload_dataset(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mbentrevett/multi30k\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'os' is not defined"
     ]
    }
   ],
   "source": [
    "os.environ['HF_ENDPOINT'] = 'https://hf-mirror.com'\n",
    "dataset = datasets.load_dataset(\"bentrevett/multi30k\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "b1cbed25-cc4f-4680-b286-9947704ed242",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'dataset' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[8], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mdataset\u001b[49m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'dataset' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "dataset"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 89,
   "id": "f7d1da6a-51e1-4512-b52c-e84b4d0ffd0b",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "train_data, valid_data, test_data = (\n",
    "    dataset[\"train\"],\n",
    "    dataset[\"validation\"],\n",
    "    dataset[\"test\"],\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 90,
   "id": "ba51fbd8-b068-4a3a-9ad4-f8b561da9293",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'en': 'Two young, White males are outside near many bushes.',\n",
       " 'de': 'Zwei junge weiße Männer sind im Freien in der Nähe vieler Büsche.'}"
      ]
     },
     "execution_count": 90,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\n",
    "train_data[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b249dacf-77c2-4e3c-8a9a-28e5a8c4691e",
   "metadata": {},
   "source": [
    "# 分词器 Tokenizers"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "8ef11022-73ac-4a47-b822-1899face1531",
   "metadata": {},
   "outputs": [],
   "source": [
    "en_nlp = spacy.load(\"en_core_web_sm\")\n",
    "de_nlp = spacy.load(\"de_core_news_sm\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 78,
   "id": "f4ad7277-8d25-4059-9e6e-a73d65a603f2",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "['What', 'a', 'lovely', 'day', 'it', 'is', 'today', '!']"
      ]
     },
     "execution_count": 78,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "string = \"What a lovely day it is today!\"\n",
    "\n",
    "[token.text for token in en_nlp.tokenizer(string)]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ba71b850-eba4-410b-87d6-80e17b66eeb5",
   "metadata": {},
   "source": [
    "### 函数  tokenize_example "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c281f1ba-f3ec-4abf-b764-5c7653909ca3",
   "metadata": {},
   "source": [
    "其功能是对包含英文和德文文本的样本进行分词、文本处理（如转换为小写），并添加开始和结束标记。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 79,
   "id": "55088033-cf2c-4469-8d2b-324915769787",
   "metadata": {},
   "outputs": [],
   "source": [
    "def tokenize_example(example, en_nlp, de_nlp, max_length, lower, sos_token, eos_token):\n",
    "    en_tokens = [token.text for token in en_nlp.tokenizer(example[\"en\"])][:max_length]\n",
    "    de_tokens = [token.text for token in de_nlp.tokenizer(example[\"de\"])][:max_length]\n",
    "    if lower:\n",
    "        en_tokens = [token.lower() for token in en_tokens]\n",
    "        de_tokens = [token.lower() for token in de_tokens]\n",
    "    en_tokens = [sos_token] + en_tokens + [eos_token]\n",
    "    de_tokens = [sos_token] + de_tokens + [eos_token]\n",
    "    return {\"en_tokens\": en_tokens, \"de_tokens\": de_tokens}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2a55722-4ac9-4c9a-be86-5e9c4e969b07",
   "metadata": {},
   "source": [
    "### sos和eos的含义 "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "ad33ae7d-3fd9-4a77-95e2-deee49fe0718",
   "metadata": {},
   "source": [
    "sos_token = \"<sos>\"  中的  \"sos\"  是 \"Start of Sentence\" 的缩写，即句子开始标记。在自然语言处理中，尤其是在序列到序列（如机器翻译）等任务里，模型需要知道一个句子从哪里开始。因此，会在每个句子的开头添加这个特殊的标记，这样模型就能识别句子的起始位置。\n",
    " \n",
    "eos_token = \"<eos>\"  中的  \"eos\"  是 \"End of Sentence\" 的缩写，即句子结束标记。类似地，模型需要知道一个句子在何处结束。在处理完一个句子的所有单词后，添加这个特殊标记，让模型明确句子的终止。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c5f93412-72a5-496f-93c4-f5d582a823a9",
   "metadata": {},
   "source": [
    "### map函数的作用"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d3c16780-b528-4b26-b7c4-d9dd4571d166",
   "metadata": {},
   "source": [
    " map  函数的作用是对数据集中的每个样本应用指定的函数"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "id": "e1b06bd5-2b30-42b2-b050-da987b82a47c",
   "metadata": {},
   "outputs": [],
   "source": [
    "max_length = 1_000\n",
    "lower = True\n",
    "sos_token = \"<sos>\"\n",
    "eos_token = \"<eos>\"\n",
    "\n",
    "fn_kwargs = {\n",
    "    \"en_nlp\": en_nlp,\n",
    "    \"de_nlp\": de_nlp,\n",
    "    \"max_length\": max_length,\n",
    "    \"lower\": lower,\n",
    "    \"sos_token\": sos_token,\n",
    "    \"eos_token\": eos_token,\n",
    "}\n",
    "\n",
    "train_data = train_data.map(tokenize_example, fn_kwargs=fn_kwargs)\n",
    "valid_data = valid_data.map(tokenize_example, fn_kwargs=fn_kwargs)\n",
    "test_data = test_data.map(tokenize_example, fn_kwargs=fn_kwargs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "id": "ffa0eada-9d40-44d2-b39e-c036ce062ac9",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "{'en': 'Two young, White males are outside near many bushes.',\n",
       " 'de': 'Zwei junge weiße Männer sind im Freien in der Nähe vieler Büsche.',\n",
       " 'en_tokens': ['<sos>',\n",
       "  'two',\n",
       "  'young',\n",
       "  ',',\n",
       "  'white',\n",
       "  'males',\n",
       "  'are',\n",
       "  'outside',\n",
       "  'near',\n",
       "  'many',\n",
       "  'bushes',\n",
       "  '.',\n",
       "  '<eos>'],\n",
       " 'de_tokens': ['<sos>',\n",
       "  'zwei',\n",
       "  'junge',\n",
       "  'weiße',\n",
       "  'männer',\n",
       "  'sind',\n",
       "  'im',\n",
       "  'freien',\n",
       "  'in',\n",
       "  'der',\n",
       "  'nähe',\n",
       "  'vieler',\n",
       "  'büsche',\n",
       "  '.',\n",
       "  '<eos>']}"
      ]
     },
     "execution_count": 81,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "train_data[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2e95e9e4-cab8-4f08-9b5f-929f8eaf1b6e",
   "metadata": {},
   "source": [
    "# 词汇表 Vocabularies"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "id": "464f097d-c3f2-4e61-abc5-8fb9fcffc5b4",
   "metadata": {},
   "outputs": [
    {
     "ename": "TypeError",
     "evalue": "build_vocab_from_iterator() got an unexpected keyword argument 'min_freq'",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[82], line 12\u001b[0m\n\u001b[0;32m      3\u001b[0m pad_token \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124m<pad>\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m      5\u001b[0m special_tokens \u001b[38;5;241m=\u001b[39m [\n\u001b[0;32m      6\u001b[0m     unk_token,\n\u001b[0;32m      7\u001b[0m     pad_token,\n\u001b[0;32m      8\u001b[0m     sos_token,\n\u001b[0;32m      9\u001b[0m     eos_token,\n\u001b[0;32m     10\u001b[0m ]\n\u001b[1;32m---> 12\u001b[0m en_vocab \u001b[38;5;241m=\u001b[39m \u001b[43mtorchtext\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mvocab\u001b[49m\u001b[38;5;241;43m.\u001b[39;49m\u001b[43mbuild_vocab_from_iterator\u001b[49m\u001b[43m(\u001b[49m\n\u001b[0;32m     13\u001b[0m \u001b[43m    \u001b[49m\u001b[43mtrain_data\u001b[49m\u001b[43m[\u001b[49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[38;5;124;43men_tokens\u001b[39;49m\u001b[38;5;124;43m\"\u001b[39;49m\u001b[43m]\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     14\u001b[0m \u001b[43m    \u001b[49m\u001b[43mmin_freq\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mmin_freq\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     15\u001b[0m \u001b[43m    \u001b[49m\u001b[43mspecials\u001b[49m\u001b[38;5;241;43m=\u001b[39;49m\u001b[43mspecial_tokens\u001b[49m\u001b[43m,\u001b[49m\n\u001b[0;32m     16\u001b[0m \u001b[43m)\u001b[49m\n\u001b[0;32m     18\u001b[0m de_vocab \u001b[38;5;241m=\u001b[39m torchtext\u001b[38;5;241m.\u001b[39mvocab\u001b[38;5;241m.\u001b[39mbuild_vocab_from_iterator(\n\u001b[0;32m     19\u001b[0m     train_data[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mde_tokens\u001b[39m\u001b[38;5;124m\"\u001b[39m],\n\u001b[0;32m     20\u001b[0m     min_freq\u001b[38;5;241m=\u001b[39mmin_freq,\n\u001b[0;32m     21\u001b[0m     specials\u001b[38;5;241m=\u001b[39mspecial_tokens,\n\u001b[0;32m     22\u001b[0m )\n",
      "\u001b[1;31mTypeError\u001b[0m: build_vocab_from_iterator() got an unexpected keyword argument 'min_freq'"
     ]
    }
   ],
   "source": [
    "min_freq = 2\n",
    "unk_token = \"<unk>\"\n",
    "pad_token = \"<pad>\"\n",
    "\n",
    "special_tokens = [\n",
    "    unk_token,\n",
    "    pad_token,\n",
    "    sos_token,\n",
    "    eos_token,\n",
    "]\n",
    "\n",
    "en_vocab = torchtext.vocab.build_vocab_from_iterator(\n",
    "    train_data[\"en_tokens\"],\n",
    "    min_freq=min_freq,\n",
    "    specials=special_tokens,\n",
    ")\n",
    "\n",
    "de_vocab = torchtext.vocab.build_vocab_from_iterator(\n",
    "    train_data[\"de_tokens\"],\n",
    "    min_freq=min_freq,\n",
    "    specials=special_tokens,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c6924b59-6b54-4a12-a3e2-42c9e9cbf7b7",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "en_vocab.get_itos()[:10]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 27,
   "id": "d3139e13-c3c1-4a3a-a137-f9a11221cca4",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'de_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[27], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mde_vocab\u001b[49m\u001b[38;5;241m.\u001b[39mget_itos()[:\u001b[38;5;241m10\u001b[39m]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'de_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "de_vocab.get_itos()[:10]\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "73919630-2699-477a-a457-c63b21a5f38f",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[11], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43men_vocab\u001b[49m[\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mthe\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "en_vocab[\"the\"]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 12,
   "id": "a93d3e7a-9bc1-4b34-983e-ab8a337990f7",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[12], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[38;5;28;01massert\u001b[39;00m \u001b[43men_vocab\u001b[49m[unk_token] \u001b[38;5;241m==\u001b[39m de_vocab[unk_token]\n\u001b[0;32m      2\u001b[0m \u001b[38;5;28;01massert\u001b[39;00m en_vocab[pad_token] \u001b[38;5;241m==\u001b[39m de_vocab[pad_token]\n\u001b[0;32m      4\u001b[0m unk_index \u001b[38;5;241m=\u001b[39m en_vocab[unk_token]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "assert en_vocab[unk_token] == de_vocab[unk_token]\n",
    "assert en_vocab[pad_token] == de_vocab[pad_token]\n",
    "\n",
    "unk_index = en_vocab[unk_token]\n",
    "pad_index = en_vocab[pad_token]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 13,
   "id": "b76d4393-d5bf-4bbd-a423-c54ff1f6142d",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[13], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43men_vocab\u001b[49m\u001b[38;5;241m.\u001b[39mset_default_index(unk_index)\n\u001b[0;32m      2\u001b[0m de_vocab\u001b[38;5;241m.\u001b[39mset_default_index(unk_index)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "en_vocab.set_default_index(unk_index)\n",
    "de_vocab.set_default_index(unk_index)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 14,
   "id": "079ff26b-0356-42b8-9699-f3ad42d82a37",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[14], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m tokens \u001b[38;5;241m=\u001b[39m [\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mi\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mlove\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mwatching\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mcrime\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mshows\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n\u001b[1;32m----> 2\u001b[0m \u001b[43men_vocab\u001b[49m\u001b[38;5;241m.\u001b[39mlookup_indices(tokens)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "tokens = [\"i\", \"love\", \"watching\", \"crime\", \"shows\"]\n",
    "en_vocab.lookup_indices(tokens)\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 15,
   "id": "e1a8281c-df5f-44bf-aa36-9f2d145bda40",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[15], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43men_vocab\u001b[49m\u001b[38;5;241m.\u001b[39mlookup_tokens(en_vocab\u001b[38;5;241m.\u001b[39mlookup_indices(tokens))\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "en_vocab.lookup_tokens(en_vocab.lookup_indices(tokens))"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a867441-c2aa-4405-a17b-ed6d22fb06af",
   "metadata": {},
   "source": [
    "### 解释为什么原本的\"crime\"被转换成了unk。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f50d494f-217a-4611-ae85-7b68ef9726a5",
   "metadata": {},
   "source": [
    "crime 不在 en_vocab 的词表中，导致被映射到 <unk>。\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "76c96291-998a-4d1c-b3c4-f61dc306e4a1",
   "metadata": {},
   "source": [
    "### 两个单元格中代码的作用"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fb2ba8e9-9e10-4a82-b1cc-b749448bae46",
   "metadata": {},
   "source": [
    "将原始文本中的单词（tokens）转换为对应的数值索引，以便模型能够处理。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "6d815572-e466-4c56-9edb-3f2208c458b9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def numericalize_example(example, en_vocab, de_vocab):\n",
    "    en_ids = en_vocab.lookup_indices(example[\"en_tokens\"])\n",
    "    de_ids = de_vocab.lookup_indices(example[\"de_tokens\"])\n",
    "    return {\"en_ids\": en_ids, \"de_ids\": de_ids}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "3c762bb3-991d-4054-8e2e-2640111e852f",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'en_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[17], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m fn_kwargs \u001b[38;5;241m=\u001b[39m {\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124men_vocab\u001b[39m\u001b[38;5;124m\"\u001b[39m: \u001b[43men_vocab\u001b[49m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mde_vocab\u001b[39m\u001b[38;5;124m\"\u001b[39m: de_vocab}\n\u001b[0;32m      3\u001b[0m train_data \u001b[38;5;241m=\u001b[39m train_data\u001b[38;5;241m.\u001b[39mmap(numericalize_example, fn_kwargs\u001b[38;5;241m=\u001b[39mfn_kwargs)\n\u001b[0;32m      4\u001b[0m valid_data \u001b[38;5;241m=\u001b[39m valid_data\u001b[38;5;241m.\u001b[39mmap(numericalize_example, fn_kwargs\u001b[38;5;241m=\u001b[39mfn_kwargs)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'en_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "fn_kwargs = {\"en_vocab\": en_vocab, \"de_vocab\": de_vocab}\n",
    "\n",
    "train_data = train_data.map(numericalize_example, fn_kwargs=fn_kwargs)\n",
    "valid_data = valid_data.map(numericalize_example, fn_kwargs=fn_kwargs)\n",
    "test_data = test_data.map(numericalize_example, fn_kwargs=fn_kwargs)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "afbbea31-58ef-40fa-92e3-6e8c1ccc994c",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'train_data' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[18], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mtrain_data\u001b[49m[\u001b[38;5;241m0\u001b[39m]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'train_data' is not defined"
     ]
    }
   ],
   "source": [
    "train_data[0]"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "56ede361-f313-4df0-91a2-5e116b84e4e9",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'train_data' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[19], line 4\u001b[0m\n\u001b[0;32m      1\u001b[0m data_type \u001b[38;5;241m=\u001b[39m \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mtorch\u001b[39m\u001b[38;5;124m\"\u001b[39m\n\u001b[0;32m      2\u001b[0m format_columns \u001b[38;5;241m=\u001b[39m [\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124men_ids\u001b[39m\u001b[38;5;124m\"\u001b[39m, \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mde_ids\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n\u001b[1;32m----> 4\u001b[0m train_data \u001b[38;5;241m=\u001b[39m \u001b[43mtrain_data\u001b[49m\u001b[38;5;241m.\u001b[39mwith_format(\n\u001b[0;32m      5\u001b[0m     \u001b[38;5;28mtype\u001b[39m\u001b[38;5;241m=\u001b[39mdata_type, columns\u001b[38;5;241m=\u001b[39mformat_columns, output_all_columns\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m\n\u001b[0;32m      6\u001b[0m )\n\u001b[0;32m      8\u001b[0m valid_data \u001b[38;5;241m=\u001b[39m valid_data\u001b[38;5;241m.\u001b[39mwith_format(\n\u001b[0;32m      9\u001b[0m     \u001b[38;5;28mtype\u001b[39m\u001b[38;5;241m=\u001b[39mdata_type,\n\u001b[0;32m     10\u001b[0m     columns\u001b[38;5;241m=\u001b[39mformat_columns,\n\u001b[0;32m     11\u001b[0m     output_all_columns\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m,\n\u001b[0;32m     12\u001b[0m )\n\u001b[0;32m     14\u001b[0m test_data \u001b[38;5;241m=\u001b[39m test_data\u001b[38;5;241m.\u001b[39mwith_format(\n\u001b[0;32m     15\u001b[0m     \u001b[38;5;28mtype\u001b[39m\u001b[38;5;241m=\u001b[39mdata_type,\n\u001b[0;32m     16\u001b[0m     columns\u001b[38;5;241m=\u001b[39mformat_columns,\n\u001b[0;32m     17\u001b[0m     output_all_columns\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m,\n\u001b[0;32m     18\u001b[0m )\n",
      "\u001b[1;31mNameError\u001b[0m: name 'train_data' is not defined"
     ]
    }
   ],
   "source": [
    "data_type = \"torch\"\n",
    "format_columns = [\"en_ids\", \"de_ids\"]\n",
    "\n",
    "train_data = train_data.with_format(\n",
    "    type=data_type, columns=format_columns, output_all_columns=True\n",
    ")\n",
    "\n",
    "valid_data = valid_data.with_format(\n",
    "    type=data_type,\n",
    "    columns=format_columns,\n",
    "    output_all_columns=True,\n",
    ")\n",
    "\n",
    "test_data = test_data.with_format(\n",
    "    type=data_type,\n",
    "    columns=format_columns,\n",
    "    output_all_columns=True,\n",
    ")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "fe45ec5c-34a0-49c5-96da-01372bd49820",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'train_data' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[20], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mtrain_data\u001b[49m[\u001b[38;5;241m0\u001b[39m]\n",
      "\u001b[1;31mNameError\u001b[0m: name 'train_data' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "train_data[0]"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "03026633-9ea3-4488-8998-79f6416f70f5",
   "metadata": {},
   "source": [
    "### 下方两个单元格中的函数的作用。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1a8e74b2-a517-42aa-8f19-e5301542f3ff",
   "metadata": {},
   "source": [
    "函数的作用是：将原始文本数据转换为模型可处理的数值化批次数据，并处理变长序列的填充问题。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "c69613b4-02c8-4137-ae5c-ab518da4211a",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_collate_fn(pad_index):\n",
    "    def collate_fn(batch):\n",
    "        batch_en_ids = [example[\"en_ids\"] for example in batch]\n",
    "        batch_de_ids = [example[\"de_ids\"] for example in batch]\n",
    "        batch_en_ids = nn.utils.rnn.pad_sequence(batch_en_ids, padding_value=pad_index)\n",
    "        batch_de_ids = nn.utils.rnn.pad_sequence(batch_de_ids, padding_value=pad_index)\n",
    "        batch = {\n",
    "            \"en_ids\": batch_en_ids,\n",
    "            \"de_ids\": batch_de_ids,\n",
    "        }\n",
    "        return batch\n",
    "\n",
    "    return collate_fn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "84b974d8-50e6-46b6-8b5d-a06f34392816",
   "metadata": {},
   "outputs": [],
   "source": [
    "def get_data_loader(dataset, batch_size, pad_index, shuffle=False):\n",
    "    collate_fn = get_collate_fn(pad_index)\n",
    "    data_loader = torch.utils.data.DataLoader(\n",
    "        dataset=dataset,\n",
    "        batch_size=batch_size,\n",
    "        collate_fn=collate_fn,\n",
    "        shuffle=shuffle,\n",
    "    )\n",
    "    return data_loader"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 23,
   "id": "bcd6c48b-5a77-4655-985d-cd1c8cf9b81d",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'train_data' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[23], line 3\u001b[0m\n\u001b[0;32m      1\u001b[0m batch_size \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m128\u001b[39m\n\u001b[1;32m----> 3\u001b[0m train_data_loader \u001b[38;5;241m=\u001b[39m get_data_loader(\u001b[43mtrain_data\u001b[49m, batch_size, pad_index, shuffle\u001b[38;5;241m=\u001b[39m\u001b[38;5;28;01mTrue\u001b[39;00m)\n\u001b[0;32m      4\u001b[0m valid_data_loader \u001b[38;5;241m=\u001b[39m get_data_loader(valid_data, batch_size, pad_index)\n\u001b[0;32m      5\u001b[0m test_data_loader \u001b[38;5;241m=\u001b[39m get_data_loader(test_data, batch_size, pad_index)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'train_data' is not defined"
     ]
    }
   ],
   "source": [
    "batch_size = 128\n",
    "\n",
    "train_data_loader = get_data_loader(train_data, batch_size, pad_index, shuffle=True)\n",
    "valid_data_loader = get_data_loader(valid_data, batch_size, pad_index)\n",
    "test_data_loader = get_data_loader(test_data, batch_size, pad_index)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "bc22450a-9c05-42f4-ad3c-60377f2d258e",
   "metadata": {},
   "source": [
    "# 编码器 Encoder"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c2d16717-9950-4b67-844e-c5d5c42a0c94",
   "metadata": {},
   "source": [
    "### 解释下方单元格中Encoder类的代码。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "c29f5c69-70ba-4b32-8c13-7e2daa00e30b",
   "metadata": {},
   "source": [
    "\n",
    "​​1️⃣ 类定义与初始化​​\n",
    "\n",
    "'''class Encoder(nn.Module):\n",
    "    def __init__(self, input_dim, embedding_dim, hidden_dim, n_layers, dropout):\n",
    "        super().__init__()\n",
    "        self.hidden_dim = hidden_dim\n",
    "        self.n_layers = n_layers\n",
    "        self.embedding = nn.Embedding(input_dim, embedding_dim)\n",
    "        self.rnn = nn.LSTM(embedding_dim, hidden_dim, n_layers, dropout=dropout)\n",
    "        self.dropout = nn.Dropout(dropout)'''\n",
    "\n",
    "​​组件作用​​：\n",
    "\n",
    "​​nn.Embedding​​:\n",
    "\n",
    "将输入的离散词索引（如 [5, 3, 2]）映射为连续的词向量。\n",
    "\n",
    "​​参数​​：\n",
    "\n",
    "input_dim: 词汇表大小（如 10,000 个单词）。\n",
    "\n",
    "embedding_dim: 词向量维度（如 256 维）。\n",
    "\n",
    "​​nn.LSTM​​:\n",
    "\n",
    "长短期记忆网络，处理序列数据并捕捉长期依赖。\n",
    "\n",
    "​​参数​​：\n",
    "\n",
    "embedding_dim: 输入维度（需与 Embedding 层输出一致）。\n",
    "\n",
    "hidden_dim: LSTM 隐藏层维度（如 512 维）。\n",
    "\n",
    "n_layers: LSTM 的堆叠层数（如 2 层）。\n",
    "\n",
    "dropout: 层间 dropout 概率（仅在多层 LSTM 中生效）。\n",
    "\n",
    "​​nn.Dropout​​:\n",
    "\n",
    "在训练时随机丢弃部分神经元，防止过拟合。\n",
    "\n",
    "2️⃣ 前向传播 (forward)​\n",
    "\n",
    "'''def forward(self, src):\n",
    "    embedded = self.dropout(self.embedding(src))  # [src_len, batch_size, emb_dim]\n",
    "    outputs, (hidden, cell) = self.rnn(embedded)\n",
    "    return hidden, cell'''\n",
    "    \n",
    "输入与输出​​：\n",
    "\n",
    "​​输入 src​​:\n",
    "\n",
    "形状：[src_len, batch_size]\n",
    "\n",
    "（例如：句子长度为 10，批次大小为 32 → [10, 32]）\n",
    "\n",
    "每个元素是词索引（如 [5, 3, 2]）。\n",
    "\n",
    "​​输出​​:\n",
    "\n",
    "hidden: 最后一层的隐藏状态，形状 [n_layers, batch_size, hidden_dim]。\n",
    "\n",
    "cell: 最后一层的细胞状态，形状与 hidden 相同。\n",
    "\n",
    "​​关键步骤​​：\n",
    "\n",
    "​​词嵌入与 Dropout​​:\n",
    "\n",
    "self.embedding(src) 将词索引转换为词向量 → 形状 [src_len, batch_size, embedding_dim]。\n",
    "\n",
    "self.dropout 对词向量进行随机置零，增强泛化性。\n",
    "\n",
    "​​LSTM 处理​​:\n",
    "\n",
    "输入 embedded 经过 LSTM 层，输出：\n",
    "\n",
    "outputs: 所有时间步的隐藏状态（通常用不到，因为只保留最后一层）。\n",
    "\n",
    "hidden: 最后一层的隐藏状态（用于传递给 Decoder）。\n",
    "\n",
    "cell: 最后一层的细胞状态（LSTM 的内部记忆）。\n",
    "\n",
    "​​3️⃣ 设计特点​​\n",
    "\n",
    "​​单向 LSTM​​:\n",
    "\n",
    "默认仅使用单向 LSTM（bidirectional=False），若需双向需修改 nn.LSTM 参数。\n",
    "\n",
    "​​多层 LSTM​​:\n",
    "\n",
    "通过 n_layers 堆叠多个 LSTM 层，深层网络可捕获更复杂的模式。\n",
    "\n",
    "​​Dropout 策略​​:\n",
    "\n",
    "仅在 LSTM 层间应用 dropout（通过 nn.LSTM 的 dropout 参数），最后一层后额外添加 self.dropout。"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 24,
   "id": "50a58180-77dc-431d-ae9d-f60bd4bfbee4",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Encoder(nn.Module):\n",
    "    def __init__(self, input_dim, embedding_dim, hidden_dim, n_layers, dropout):\n",
    "        super().__init__()\n",
    "        self.hidden_dim = hidden_dim\n",
    "        self.n_layers = n_layers\n",
    "        self.embedding = nn.Embedding(input_dim, embedding_dim)\n",
    "        self.rnn = nn.LSTM(embedding_dim, hidden_dim, n_layers, dropout=dropout)\n",
    "        self.dropout = nn.Dropout(dropout)\n",
    "\n",
    "    def forward(self, src):\n",
    "        # src = [src length, batch size]\n",
    "        embedded = self.dropout(self.embedding(src))\n",
    "        # embedded = [src length, batch size, embedding dim]\n",
    "        outputs, (hidden, cell) = self.rnn(embedded)\n",
    "        # outputs = [src length, batch size, hidden dim * n directions]\n",
    "        # hidden = [n layers * n directions, batch size, hidden dim]\n",
    "        # cell = [n layers * n directions, batch size, hidden dim]\n",
    "        # outputs are always from the top hidden layer\n",
    "        return hidden, cell"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d34302b0-df1c-4cde-8fb0-2303e67980cb",
   "metadata": {},
   "source": [
    "# 解码器 Decoder"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e83d1235-e6e2-4ef8-b5ec-9df3dc07c8a1",
   "metadata": {},
   "source": [
    "### 描述Decoder的工作流程。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "d83139e5-1172-450d-8d95-7aa66acef121",
   "metadata": {},
   "source": [
    "1️⃣ 核心目标：序列生成​​\n",
    "\n",
    "Decoder 的作用是根据 Encoder 编码的上下文信息（hidden 和 cell 状态），​​自回归地生成目标序列​​（如翻译后的句子）。每次处理一个时间步，逐步预测下一个词。\n",
    "\n",
    "​​2️⃣ 输入与输出​​\n",
    "\n",
    "​​输入​​：\n",
    "\n",
    "input: 上一个时间步生成的词索引（训练时为真实标签，推理时为模型预测的词）。\n",
    "\n",
    "形状：[batch_size]（例如：批次中每个样本的上一个词索引）。\n",
    "\n",
    "hidden 和 cell: Encoder 传递的初始状态（或前一步的隐藏状态）。\n",
    "\n",
    "形状：[n_layers, batch_size, hidden_dim]。\n",
    "\n",
    "​​输出​​：\n",
    "\n",
    "prediction: 当前时间步的预测词概率分布。\n",
    "\n",
    "形状：[batch_size, output_dim]（例如：德语词汇表大小的向量）。\n",
    "\n",
    "更新后的 hidden 和 cell 状态，供下一个时间步使用。\n",
    "\n",
    "​​3️⃣ 前向传播 (forward) 流程​​\n",
    "\n",
    "​​步骤 1：输入形状调整​​\n",
    "\n",
    "input = input.unsqueeze(0)  # 从 [batch_size] → [1, batch_size]\n",
    "\n",
    "​​目的​​：将单步输入转换为 LSTM 需要的序列格式 [seq_len, batch_size]（此处 seq_len=1）。\n",
    "\n",
    "​​步骤 2：词嵌入与 Dropout​​\n",
    "\n",
    "embedded = self.dropout(self.embedding(input))  # [1, batch_size, embedding_dim]\n",
    "\n",
    "​​词嵌入​​：将离散词索引映射为连续向量。\n",
    "\n",
    "​​Dropout​​：随机丢弃部分词向量维度，防止过拟合。\n",
    "\n",
    "​​步骤 3：LSTM 处理​​\n",
    "\n",
    "output, (hidden, cell) = self.rnn(embedded, (hidden, cell))\n",
    "\n",
    "​​输入​​：\n",
    "\n",
    "embedded: 当前时间步的词向量。\n",
    "\n",
    "hidden 和 cell: 前一步的隐藏状态和细胞状态。\n",
    "\n",
    "​​输出​​：\n",
    "\n",
    "output: 当前时间步的隐藏状态（实际未直接使用）。\n",
    "\n",
    "hidden 和 cell: 更新后的状态，传递给下一步。\n",
    "\n",
    "​​步骤 4：预测生成​​\n",
    "\n",
    "prediction = self.fc_out(output.squeeze(0))  # 从 [1, batch_size, hidden_dim] → [batch_size, output_dim]\n",
    "\n",
    "​​Squeeze​​: 移除多余的序列长度维度（seq_len=1）。\n",
    "\n",
    "​​全连接层​​：将 LSTM 输出映射到目标词汇表空间（如德语词汇表大小）。\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 25,
   "id": "912fab46-c2b9-48ce-9b0a-72730e8bc5c1",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Decoder(nn.Module):\n",
    "    def __init__(self, output_dim, embedding_dim, hidden_dim, n_layers, dropout):\n",
    "        super().__init__()\n",
    "        self.output_dim = output_dim\n",
    "        self.hidden_dim = hidden_dim\n",
    "        self.n_layers = n_layers\n",
    "        self.embedding = nn.Embedding(output_dim, embedding_dim)\n",
    "        self.rnn = nn.LSTM(embedding_dim, hidden_dim, n_layers, dropout=dropout)\n",
    "        self.fc_out = nn.Linear(hidden_dim, output_dim)\n",
    "        self.dropout = nn.Dropout(dropout)\n",
    "\n",
    "    def forward(self, input, hidden, cell):\n",
    "        # input = [batch size]\n",
    "        # hidden = [n layers * n directions, batch size, hidden dim]\n",
    "        # cell = [n layers * n directions, batch size, hidden dim]\n",
    "        # n directions in the decoder will both always be 1, therefore:\n",
    "        # hidden = [n layers, batch size, hidden dim]\n",
    "        # context = [n layers, batch size, hidden dim]\n",
    "        input = input.unsqueeze(0)\n",
    "        # input = [1, batch size]\n",
    "        embedded = self.dropout(self.embedding(input))\n",
    "        # embedded = [1, batch size, embedding dim]\n",
    "        output, (hidden, cell) = self.rnn(embedded, (hidden, cell))\n",
    "        # output = [seq length, batch size, hidden dim * n directions]\n",
    "        # hidden = [n layers * n directions, batch size, hidden dim]\n",
    "        # cell = [n layers * n directions, batch size, hidden dim]\n",
    "        # seq length and n directions will always be 1 in this decoder, therefore:\n",
    "        # output = [1, batch size, hidden dim]\n",
    "        # hidden = [n layers, batch size, hidden dim]\n",
    "        # cell = [n layers, batch size, hidden dim]\n",
    "        prediction = self.fc_out(output.squeeze(0))\n",
    "        # prediction = [batch size, output dim]\n",
    "        return prediction, hidden, cell"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b0e6e8ce-75bf-4223-85fb-9a2b6083807b",
   "metadata": {},
   "source": [
    "### 解释下方单元格中Seq2Seq类的代码。"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f798a810-0b54-41c7-9631-e9a62d0e7c8a",
   "metadata": {},
   "source": [
    "​​1️⃣ 类定义与初始化​​\n",
    "\n",
    "'''class Seq2Seq(nn.Module):\n",
    "    def __init__(self, encoder, decoder, device):\n",
    "        super().__init__()\n",
    "        self.encoder = encoder\n",
    "        self.decoder = decoder\n",
    "        self.device = device\n",
    "        # 确保编码器和解码器的隐藏层维度、层数一致\n",
    "        assert encoder.hidden_dim == decoder.hidden_dim, \"隐藏层维度必须一致！\"\n",
    "        assert encoder.n_layers == decoder.n_layers, \"层数必须一致！\"'''\n",
    "\n",
    "​​关键设计点​​：\n",
    "\n",
    "​​编码器-解码器架构​​：encoder 处理输入序列，decoder 生成输出序列。\n",
    "\n",
    "​​设备管理​​：确保张量在 CPU/GPU 上正确分配。\n",
    "\n",
    "​​2️⃣ forward 函数流程​​\n",
    "\n",
    "​​输入​​：\n",
    "\n",
    "src: 输入序列（源语言），形状 [src_len, batch_size]。\n",
    "\n",
    "trg: 目标序列（目标语言），形状 [trg_len, batch_size]（含 <sos> 和 <eos>）。\n",
    "\n",
    "teacher_forcing_ratio: 使用真实标签作为下一步输入的概率（如 0.75）。\n",
    "\n",
    "​​输出​​：\n",
    "\n",
    "outputs: 所有时间步的预测结果，形状 [trg_len, batch_size, trg_vocab_size]。\n",
    "\n",
    "​​步骤解析​​：\n",
    "\n",
    "​​初始化​​：\n",
    "\n",
    "'''batch_size = trg.shape[1]\n",
    "trg_length = trg.shape[0]\n",
    "outputs = torch.zeros(trg_length, batch_size, self.decoder.output_dim).to(self.device)\n",
    "hidden, cell = self.encoder(src)  # 编码器生成初始状态\n",
    "input = trg[0, :]  # 第一个输入是 <sos> 符号'''\n",
    "\n",
    "​​循环生成序列​​（从时间步 1 到 trg_length-1）：\n",
    "\n",
    "'''for t in range(1, trg_length):\n",
    "    output, hidden, cell = self.decoder(input, hidden, cell)  # 解码器单步推理\n",
    "    outputs[t] = output  # 保存当前时间步的预测\n",
    "    \n",
    "    # Teacher Forcing 决策\n",
    "    teacher_force = random.random() < teacher_forcing_ratio\n",
    "    top1 = output.argmax(1)  # 当前预测的词\n",
    "    input = trg[t] if teacher_force else top1  # 输入下一时间步的真实词或预测词'''\n",
    "    \n",
    "​​返回结果​​：\n",
    "\n",
    "return outputs  # 所有时间步的预测\n",
    "\n",
    "​​3️⃣ Teacher Forcing 机制​​\n",
    "\n",
    "\n",
    "​​作用​​：\n",
    "\n",
    "​​训练阶段​​：以一定概率（teacher_forcing_ratio）使用 ​​真实标签​​（trg[t]）作为解码器的下一个输入，而非模型预测的词。\n",
    "\n",
    "​​目的​​：加速模型收敛，减少误差累积。\n",
    "\n",
    "​​流程示例​​：\n",
    "假设 teacher_forcing_ratio=0.75：\n",
    "\n",
    "​​75% 的情况​​：输入为真实标签（如 trg[1]）。\n",
    "\n",
    "​​25% 的情况​​：输入为模型预测的词（如 top1）。\n",
    "\n",
    "​​代码实现​​：\n",
    "\n",
    "'''teacher_force = random.random() < teacher_forcing_ratio\n",
    "input = trg[t] if teacher_force else top1'''\n",
    "\n",
    "​​4️⃣输出与损失计算​​\n",
    "\n",
    "​​输出形状​​：[trg_len, batch_size, trg_vocab_size]。\n",
    "\n",
    "​​损失计算​​：对比每个时间步的预测与真实标签（忽略 <pad>）。\n",
    "\n",
    "loss = criterion(outputs[1:].view(-1, trg_vocab_size), trg[1:].view(-1))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 26,
   "id": "806a2fe5-46dd-4162-aee3-9aa2a5bd8f43",
   "metadata": {},
   "outputs": [],
   "source": [
    "class Seq2Seq(nn.Module):\n",
    "    def __init__(self, encoder, decoder, device):\n",
    "        super().__init__()\n",
    "        self.encoder = encoder\n",
    "        self.decoder = decoder\n",
    "        self.device = device\n",
    "        assert (\n",
    "            encoder.hidden_dim == decoder.hidden_dim\n",
    "        ), \"Hidden dimensions of encoder and decoder must be equal!\"\n",
    "        assert (\n",
    "            encoder.n_layers == decoder.n_layers\n",
    "        ), \"Encoder and decoder must have equal number of layers!\"\n",
    "\n",
    "    def forward(self, src, trg, teacher_forcing_ratio):\n",
    "        # src = [src length, batch size]\n",
    "        # trg = [trg length, batch size]\n",
    "        # teacher_forcing_ratio is probability to use teacher forcing\n",
    "        # e.g. if teacher_forcing_ratio is 0.75 we use ground-truth inputs 75% of the time\n",
    "        batch_size = trg.shape[1]\n",
    "        trg_length = trg.shape[0]\n",
    "        trg_vocab_size = self.decoder.output_dim\n",
    "        # tensor to store decoder outputs\n",
    "        outputs = torch.zeros(trg_length, batch_size, trg_vocab_size).to(self.device)\n",
    "        # last hidden state of the encoder is used as the initial hidden state of the decoder\n",
    "        hidden, cell = self.encoder(src)\n",
    "        # hidden = [n layers * n directions, batch size, hidden dim]\n",
    "        # cell = [n layers * n directions, batch size, hidden dim]\n",
    "        # first input to the decoder is the <sos> tokens\n",
    "        input = trg[0, :]\n",
    "        # input = [batch size]\n",
    "        for t in range(1, trg_length):\n",
    "            # insert input token embedding, previous hidden and previous cell states\n",
    "            # receive output tensor (predictions) and new hidden and cell states\n",
    "            output, hidden, cell = self.decoder(input, hidden, cell)\n",
    "            # output = [batch size, output dim]\n",
    "            # hidden = [n layers, batch size, hidden dim]\n",
    "            # cell = [n layers, batch size, hidden dim]\n",
    "            # place predictions in a tensor holding predictions for each token\n",
    "            outputs[t] = output\n",
    "            # decide if we are going to use teacher forcing or not\n",
    "            teacher_force = random.random() < teacher_forcing_ratio\n",
    "            # get the highest predicted token from our predictions\n",
    "            top1 = output.argmax(1)\n",
    "            # if teacher forcing, use actual next token as next input\n",
    "            # if not, use predicted token\n",
    "            input = trg[t] if teacher_force else top1\n",
    "            # input = [batch size]\n",
    "        return outputs\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "447b42aa-2a9d-4d90-a84c-271508166346",
   "metadata": {},
   "source": [
    "\n",
    "# 模型训练 分别将“# 编码器初始化”，“# 解码器初始化”，“# Seq2Seq模型整合”这三行注释加到下方单元格中正确的位置"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "e025d26c-7c40-4904-8667-38e75a60c3c5",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'de_vocab' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[3], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;66;03m# 编码器初始化\u001b[39;00m\n\u001b[1;32m----> 2\u001b[0m input_dim \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlen\u001b[39m(\u001b[43mde_vocab\u001b[49m)\n\u001b[0;32m      3\u001b[0m output_dim \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mlen\u001b[39m(en_vocab)\n\u001b[0;32m      4\u001b[0m encoder_embedding_dim \u001b[38;5;241m=\u001b[39m \u001b[38;5;241m256\u001b[39m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'de_vocab' is not defined"
     ]
    }
   ],
   "source": [
    "# 编码器初始化\n",
    "input_dim = len(de_vocab)\n",
    "output_dim = len(en_vocab)\n",
    "encoder_embedding_dim = 256\n",
    "decoder_embedding_dim = 256\n",
    "hidden_dim = 512\n",
    "n_layers = 2\n",
    "encoder_dropout = 0.5\n",
    "decoder_dropout = 0.5\n",
    "device = torch.device(\"cuda\" if torch.cuda.is_available() else \"cpu\")\n",
    "\n",
    "encoder = Encoder(\n",
    "    input_dim,\n",
    "    encoder_embedding_dim,\n",
    "    hidden_dim,\n",
    "    n_layers,\n",
    "    encoder_dropout,\n",
    ")\n",
    "# 解码器初始化\n",
    "decoder = Decoder(\n",
    "    output_dim,\n",
    "    decoder_embedding_dim,\n",
    "    hidden_dim,\n",
    "    n_layers,\n",
    "    decoder_dropout,\n",
    ")\n",
    "# Seq2Seq模型整合\n",
    "model = Seq2Seq(encoder, decoder, device).to(device)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 28,
   "id": "1ba5e387-7e7c-47fd-979b-21195e56b931",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[28], line 6\u001b[0m\n\u001b[0;32m      2\u001b[0m     \u001b[38;5;28;01mfor\u001b[39;00m name, param \u001b[38;5;129;01min\u001b[39;00m m\u001b[38;5;241m.\u001b[39mnamed_parameters():\n\u001b[0;32m      3\u001b[0m         nn\u001b[38;5;241m.\u001b[39minit\u001b[38;5;241m.\u001b[39muniform_(param\u001b[38;5;241m.\u001b[39mdata, \u001b[38;5;241m-\u001b[39m\u001b[38;5;241m0.08\u001b[39m, \u001b[38;5;241m0.08\u001b[39m)\n\u001b[1;32m----> 6\u001b[0m \u001b[43mmodel\u001b[49m\u001b[38;5;241m.\u001b[39mapply(init_weights)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "def init_weights(m):\n",
    "    for name, param in m.named_parameters():\n",
    "        nn.init.uniform_(param.data, -0.08, 0.08)\n",
    "\n",
    "\n",
    "model.apply(init_weights)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 29,
   "id": "8c8e0fb0-5a8b-499d-aff8-27cd206e6790",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[29], line 5\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[38;5;28;01mdef\u001b[39;00m\u001b[38;5;250m \u001b[39m\u001b[38;5;21mcount_parameters\u001b[39m(model):\n\u001b[0;32m      2\u001b[0m     \u001b[38;5;28;01mreturn\u001b[39;00m \u001b[38;5;28msum\u001b[39m(p\u001b[38;5;241m.\u001b[39mnumel() \u001b[38;5;28;01mfor\u001b[39;00m p \u001b[38;5;129;01min\u001b[39;00m model\u001b[38;5;241m.\u001b[39mparameters() \u001b[38;5;28;01mif\u001b[39;00m p\u001b[38;5;241m.\u001b[39mrequires_grad)\n\u001b[1;32m----> 5\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mThe model has \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mcount_parameters(model)\u001b[38;5;132;01m:\u001b[39;00m\u001b[38;5;124m,\u001b[39m\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m trainable parameters\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "def count_parameters(model):\n",
    "    return sum(p.numel() for p in model.parameters() if p.requires_grad)\n",
    "\n",
    "\n",
    "print(f\"The model has {count_parameters(model):,} trainable parameters\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 30,
   "id": "dfc45bdf-8a86-407d-9584-9ee456f5dbfc",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[30], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m optimizer \u001b[38;5;241m=\u001b[39m optim\u001b[38;5;241m.\u001b[39mAdam(\u001b[43mmodel\u001b[49m\u001b[38;5;241m.\u001b[39mparameters())\n",
      "\u001b[1;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "optimizer = optim.Adam(model.parameters())"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 31,
   "id": "e02e8b0f-2373-4924-9852-0313f0c56229",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'pad_index' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[31], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m criterion \u001b[38;5;241m=\u001b[39m nn\u001b[38;5;241m.\u001b[39mCrossEntropyLoss(ignore_index\u001b[38;5;241m=\u001b[39m\u001b[43mpad_index\u001b[49m)\n",
      "\u001b[1;31mNameError\u001b[0m: name 'pad_index' is not defined"
     ]
    }
   ],
   "source": [
    "criterion = nn.CrossEntropyLoss(ignore_index=pad_index)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3a6074ba-f566-4a45-9ebc-6251e6f4211c",
   "metadata": {},
   "source": [
    "  ### 给下方单元格中的代码逐行加注释"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "fab17384-393d-4edd-a339-da753cb19afe",
   "metadata": {},
   "outputs": [],
   "source": [
    "def train_fn(\n",
    "    model, data_loader, optimizer, criterion, clip, teacher_forcing_ratio, device\n",
    "):\n",
    "    # 将模型设置为训练模式（启用Dropout等训练特有层）\n",
    "    model.train()\n",
    "    epoch_loss = 0  # 初始化当前epoch的总损失\n",
    "\n",
    "    # 遍历数据加载器中的每个批次\n",
    "    for i, batch in enumerate(data_loader):\n",
    "        # 将源语言ID和目标语言ID加载到设备（GPU/CPU）\n",
    "        src = batch[\"de_ids\"].to(device)  # 形状: [src_len, batch_size]\n",
    "        trg = batch[\"en_ids\"].to(device)  # 形状: [trg_len, batch_size]\n",
    "\n",
    "        # 清空优化器中累积的梯度（防止梯度累积）\n",
    "        optimizer.zero_grad()\n",
    "\n",
    "        # 前向传播：执行seq2seq模型的前向计算\n",
    "        # teacher_forcing_ratio控制使用真实标签作为下一步输入的概率\n",
    "        output = model(src, trg, teacher_forcing_ratio)  \n",
    "        # output形状: [trg_len, batch_size, trg_vocab_size]\n",
    "\n",
    "        # 移除目标序列的第一个时间步（<sos>标记不参与损失计算）\n",
    "        output = output[1:].view(-1, output.shape[-1])  \n",
    "        # 新形状: [(trg_len-1)*batch_size, trg_vocab_size]\n",
    "\n",
    "        # 移除目标序列的第一个时间步（与output对齐）\n",
    "        trg = trg[1:].view(-1)  \n",
    "        # 新形状: [(trg_len-1)*batch_size]\n",
    "\n",
    "        # 计算交叉熵损失（忽略<pad>标记）\n",
    "        loss = criterion(output, trg)  # 输出与目标形状匹配\n",
    "\n",
    "        # 反向传播计算梯度\n",
    "        loss.backward()\n",
    "\n",
    "        # 梯度裁剪：防止梯度爆炸（clip参数控制最大梯度范数）\n",
    "        torch.nn.utils.clip_grad_norm_(model.parameters(), clip)\n",
    "\n",
    "        # 更新模型参数\n",
    "        optimizer.step()\n",
    "\n",
    "        # 累加当前批次的损失（用于计算平均损失）\n",
    "        epoch_loss += loss.item()\n",
    "\n",
    "    # 返回当前epoch的平均损失\n",
    "    return epoch_loss / len(data_loader)\n",
    "  "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 33,
   "id": "b283ee5d-b3ca-4f7f-a2c4-6a7a436a5c57",
   "metadata": {},
   "outputs": [],
   "source": [
    "def evaluate_fn(model, data_loader, criterion, device):\n",
    "    model.eval()\n",
    "    epoch_loss = 0\n",
    "    with torch.no_grad():\n",
    "        for i, batch in enumerate(data_loader):\n",
    "            src = batch[\"de_ids\"].to(device)\n",
    "            trg = batch[\"en_ids\"].to(device)\n",
    "            # src = [src length, batch size]\n",
    "            # trg = [trg length, batch size]\n",
    "            output = model(src, trg, 0)  # turn off teacher forcing\n",
    "            # output = [trg length, batch size, trg vocab size]\n",
    "            output_dim = output.shape[-1]\n",
    "            output = output[1:].view(-1, output_dim)\n",
    "            # output = [(trg length - 1) * batch size, trg vocab size]\n",
    "            trg = trg[1:].view(-1)\n",
    "            # trg = [(trg length - 1) * batch size]\n",
    "            loss = criterion(output, trg)\n",
    "            epoch_loss += loss.item()\n",
    "    return epoch_loss / len(data_loader)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "cceb372a-7ddd-48aa-9aee-7ad74d5a62f9",
   "metadata": {},
   "source": [
    "# 模型训练"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 34,
   "id": "0c7cad80-90a4-4264-8f44-2f9f7fcd6e17",
   "metadata": {},
   "outputs": [
    {
     "name": "stderr",
     "output_type": "stream",
     "text": [
      "  0%|                                                                                            | 0/1 [00:00<?, ?it/s]\n"
     ]
    },
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[34], line 9\u001b[0m\n\u001b[0;32m      5\u001b[0m best_valid_loss \u001b[38;5;241m=\u001b[39m \u001b[38;5;28mfloat\u001b[39m(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124minf\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m      7\u001b[0m \u001b[38;5;28;01mfor\u001b[39;00m epoch \u001b[38;5;129;01min\u001b[39;00m tqdm\u001b[38;5;241m.\u001b[39mtqdm(\u001b[38;5;28mrange\u001b[39m(n_epochs)):\n\u001b[0;32m      8\u001b[0m     train_loss \u001b[38;5;241m=\u001b[39m train_fn(\n\u001b[1;32m----> 9\u001b[0m         \u001b[43mmodel\u001b[49m,\n\u001b[0;32m     10\u001b[0m         train_data_loader,\n\u001b[0;32m     11\u001b[0m         optimizer,\n\u001b[0;32m     12\u001b[0m         criterion,\n\u001b[0;32m     13\u001b[0m         clip,\n\u001b[0;32m     14\u001b[0m         teacher_forcing_ratio,\n\u001b[0;32m     15\u001b[0m         device,\n\u001b[0;32m     16\u001b[0m     )\n\u001b[0;32m     17\u001b[0m     valid_loss \u001b[38;5;241m=\u001b[39m evaluate_fn(\n\u001b[0;32m     18\u001b[0m         model,\n\u001b[0;32m     19\u001b[0m         valid_data_loader,\n\u001b[0;32m     20\u001b[0m         criterion,\n\u001b[0;32m     21\u001b[0m         device,\n\u001b[0;32m     22\u001b[0m     )\n\u001b[0;32m     23\u001b[0m     \u001b[38;5;28;01mif\u001b[39;00m valid_loss \u001b[38;5;241m<\u001b[39m best_valid_loss:\n",
      "\u001b[1;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "n_epochs = 1 # 因模型训练对计算资源要求较高，此处只设立了一轮训练。\n",
    "clip = 1.0\n",
    "teacher_forcing_ratio = 0.5\n",
    "\n",
    "best_valid_loss = float(\"inf\")\n",
    "\n",
    "for epoch in tqdm.tqdm(range(n_epochs)):\n",
    "    train_loss = train_fn(\n",
    "        model,\n",
    "        train_data_loader,\n",
    "        optimizer,\n",
    "        criterion,\n",
    "        clip,\n",
    "        teacher_forcing_ratio,\n",
    "        device,\n",
    "    )\n",
    "    valid_loss = evaluate_fn(\n",
    "        model,\n",
    "        valid_data_loader,\n",
    "        criterion,\n",
    "        device,\n",
    "    )\n",
    "    if valid_loss < best_valid_loss:\n",
    "        best_valid_loss = valid_loss\n",
    "        torch.save(model.state_dict(), \"tut1-model.pt\")\n",
    "    print(f\"\\tTrain Loss: {train_loss:7.3f} | Train PPL: {np.exp(train_loss):7.3f}\")\n",
    "    print(f\"\\tValid Loss: {valid_loss:7.3f} | Valid PPL: {np.exp(valid_loss):7.3f}\")"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "0667cc2d-949c-4e46-a3ce-cbeb44fc712c",
   "metadata": {},
   "source": [
    "# 模型验证"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 35,
   "id": "cffb2cd0-b20d-4abd-bf72-18593e7ad3eb",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'model' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[35], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mmodel\u001b[49m\u001b[38;5;241m.\u001b[39mload_state_dict(torch\u001b[38;5;241m.\u001b[39mload(\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mtut1-model.pt\u001b[39m\u001b[38;5;124m\"\u001b[39m))\n",
      "\u001b[1;31mNameError\u001b[0m: name 'model' is not defined"
     ]
    }
   ],
   "source": [
    "model.load_state_dict(torch.load(\"tut1-model.pt\"))"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 36,
   "id": "55714803-b60f-4030-84d4-4790010409cc",
   "metadata": {},
   "outputs": [],
   "source": [
    "def translate_sentence(\n",
    "    sentence,\n",
    "    model,\n",
    "    en_nlp,\n",
    "    de_nlp,\n",
    "    en_vocab,\n",
    "    de_vocab,\n",
    "    lower,\n",
    "    sos_token,\n",
    "    eos_token,\n",
    "    device,\n",
    "    max_output_length=25,\n",
    "):\n",
    "    model.eval()\n",
    "    with torch.no_grad():\n",
    "        if isinstance(sentence, str):\n",
    "            tokens = [token.text for token in de_nlp.tokenizer(sentence)]\n",
    "        else:\n",
    "            tokens = [token for token in sentence]\n",
    "        if lower:\n",
    "            tokens = [token.lower() for token in tokens]\n",
    "        tokens = [sos_token] + tokens + [eos_token]\n",
    "        ids = de_vocab.lookup_indices(tokens)\n",
    "        tensor = torch.LongTensor(ids).unsqueeze(-1).to(device)\n",
    "        hidden, cell = model.encoder(tensor)\n",
    "        inputs = en_vocab.lookup_indices([sos_token])\n",
    "        for _ in range(max_output_length):\n",
    "            inputs_tensor = torch.LongTensor([inputs[-1]]).to(device)\n",
    "            output, hidden, cell = model.decoder(inputs_tensor, hidden, cell)\n",
    "            predicted_token = output.argmax(-1).item()\n",
    "            inputs.append(predicted_token)\n",
    "            if predicted_token == en_vocab[eos_token]:\n",
    "                break\n",
    "        tokens = en_vocab.lookup_tokens(inputs)\n",
    "    return tokens\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 37,
   "id": "02d83953-a86d-4a7b-8347-542424ead359",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'test_data' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[37], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m sentence \u001b[38;5;241m=\u001b[39m \u001b[43mtest_data\u001b[49m[\u001b[38;5;241m0\u001b[39m][\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mde\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n\u001b[0;32m      2\u001b[0m expected_translation \u001b[38;5;241m=\u001b[39m test_data[\u001b[38;5;241m0\u001b[39m][\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124men\u001b[39m\u001b[38;5;124m\"\u001b[39m]\n\u001b[0;32m      4\u001b[0m sentence, expected_translation\n",
      "\u001b[1;31mNameError\u001b[0m: name 'test_data' is not defined"
     ]
    }
   ],
   "source": [
    "sentence = test_data[0][\"de\"]\n",
    "expected_translation = test_data[0][\"en\"]\n",
    "\n",
    "sentence, expected_translation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 38,
   "id": "415a1174-a061-4a53-b892-51653fec5671",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'sentence' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[38], line 2\u001b[0m\n\u001b[0;32m      1\u001b[0m translation \u001b[38;5;241m=\u001b[39m translate_sentence(\n\u001b[1;32m----> 2\u001b[0m     \u001b[43msentence\u001b[49m,\n\u001b[0;32m      3\u001b[0m     model,\n\u001b[0;32m      4\u001b[0m     en_nlp,\n\u001b[0;32m      5\u001b[0m     de_nlp,\n\u001b[0;32m      6\u001b[0m     en_vocab,\n\u001b[0;32m      7\u001b[0m     de_vocab,\n\u001b[0;32m      8\u001b[0m     lower,\n\u001b[0;32m      9\u001b[0m     sos_token,\n\u001b[0;32m     10\u001b[0m     eos_token,\n\u001b[0;32m     11\u001b[0m     device,\n\u001b[0;32m     12\u001b[0m )\n",
      "\u001b[1;31mNameError\u001b[0m: name 'sentence' is not defined"
     ]
    }
   ],
   "source": [
    "translation = translate_sentence(\n",
    "    sentence,\n",
    "    model,\n",
    "    en_nlp,\n",
    "    de_nlp,\n",
    "    en_vocab,\n",
    "    de_vocab,\n",
    "    lower,\n",
    "    sos_token,\n",
    "    eos_token,\n",
    "    device,\n",
    ")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 39,
   "id": "14fbfbff-9f61-4a87-9222-84c042b3a5f9",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name 'translation' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[39], line 1\u001b[0m\n\u001b[1;32m----> 1\u001b[0m \u001b[43mtranslation\u001b[49m\n",
      "\u001b[1;31mNameError\u001b[0m: name 'translation' is not defined"
     ]
    }
   ],
   "source": [
    "\n",
    "translation"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c40766d5-832c-4ecb-bf7b-9d402c10c57a",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.21"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
